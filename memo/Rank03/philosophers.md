### pthreadとは？

一言で言うと、
**pthread（POSIXスレッド）**
は、
**1つのプログラムの中で複数の処理を同時に（並行して）実行するための標準的な仕組み（API）**
です。

---

### なぜpthreadを使うのか？

1.  **パフォーマンスの向上 🚀**
    * 時間のかかる処理（例: 大きなファイルの読み込み、動画のエンコード、複雑な科学技術計算）を複数のスレッドに分担させることで、全体の処理時間を短縮できます。最近のCPUは複数のコアを持っているので、スレッドを別々のコアで同時に動かすことで**本当の意味で並列処理**ができ、性能が劇的に向上します。

2.  **応答性の維持 쾌**
    * 例えば、GUIアプリケーションで重い処理をメインの1本のスレッドで実行すると、処理が終わるまで画面が固まってしまいます（フリーズ）。
    * 重い処理を別のスレッドに任せることで、メインスレッドはユーザーの操作（ボタンクリックなど）にすぐに応答できるようになり、アプリケーションの操作性が良くなります。

---

### 基本的な使い方と重要キーワード 🛠️

| 機能 | 関数/型 | 例え（シェフ） | 説明 |
| :--- | :--- | :--- | :--- |
| **スレッドID** | `pthread_t` | 各シェフの**名札** | 作成したスレッドを識別するための変数。 |
| **スreadの作成** | `pthread_create()` | 新しいシェフを**雇う** | 新しいスレッドを起動し、指定した関数（仕事）を実行させる。 |
| **スレッドの終了待ち** | `pthread_join()` | シェフの仕事が**終わるのを待つ** | 指定したスレッドの処理が完了するまで、呼び出し元のスレッドの処理を一時停止する。 |

#### 最大の注意点：共有リソースと競合状態 💥

複数のスレッドが**同じ変数（共有リソース）**に同時に書き込みを行うと、データが壊れて予期せぬ結果になることがあります。これを**競合状態（Race Condition）**と呼びます。

#### 解決策：Mutex（ミューテックス） 🔑

この問題を解決するのが **Mutex（ミューテックス）** です。これは**「共有リソースの鍵」**のようなものです。

* 共有の道具（変数）を使いたいシェフ（スレッド）は、まず鍵（ロック）を手に入れます。
* 鍵を持っているシェフだけが、その道具を使えます。
* 他のシェフは、鍵が返される（アンロック）まで待たなければなりません。



これにより、一度に1つのスレッドしか共有変数を操作できなくなり、データの安全性が保たれます。これを**排他制御**と呼びます。

| 機能 | 関数/型 | 例え | 説明 |
| :--- | :--- | :--- | :--- |
| **Mutex変数** | `pthread_mutex_t` | 共有トイレの**鍵** | 共有リソースを保護するためのロック機構。 |
| **ロック** | `pthread_mutex_lock()` | 鍵を**かける** | 共有リソースへのアクセス権を取得する。 |
| **アンロック** | `pthread_mutex_unlock()` | 鍵を**あける** | 共有リソースへのアクセス権を解放する。 |

---

### まとめ

* **pthread**は、プログラム内で**複数の処理を並行して実行する**ための仕組み。
* 主な目的は**パフォーマンス向上**と**応答性の維持**。
* `pthread_create`でスレッドを作り、`pthread_join`で終了を待つのが基本。
* 複数のスレッドが同じ変数を触ると**競合状態**という危険な問題が起きる。
* それを防ぐために**Mutex**を使って、共有リソースをロックし、保護する必要がある。



## Mutex（ミューテックス）とは？
Mutexは "Mutual Exclusion"（相互排他）の略で、複数のスレッドが同時にアクセスしてはいけない共有リソース（このコードでは変数 a）を保護するための仕組みです。

ミューテックスを使うことで、共有リソースを操作するコードの区間（クリティカルセクション）を、一度に1つのスreadしか実行できないように保証します。


1. Mutex変数の宣言
```c
pthread_mutex_t mutex;
```
プログラム全体で使うためのミューテックス変数を宣言します。これが「鍵」そのものです。

2. Mutexの初期化
```c
int main(void) {
  pthread_mutex_init(&mutex, NULL);
  // ...
}
```
main関数の最初で、ミューテックスオブジェクトを初期化します。これを使える状態にする（鍵を作って使えるように準備する）操作です。第2引数にNULLを指定すると、デフォルトの属性で初期化されます。

3. ロックとアンロック
```c
// ... ループ内 ...
pthread_mutex_lock(&mutex);      // 鍵をかける（クリティカルセクションの開始）

// --- ここからクリティカルセクション ---
int next = a + 1;
int now = a;
a = next;
// --- ここまでクリティカルセクション ---

pthread_mutex_unlock(&mutex);    // 鍵をあける（クリティカルセクションの終了）
pthread_mutex_lock(&mutex);
```
共有変数 a にアクセスする直前に呼び出します。

もし他のスレッドが既にこのミューテックスをロックしていた場合、そのスレッドがアンロックするまで、この関数の実行は**ブロック（待機）**されます。

ロックが成功すると、処理が先に進みます。

``pthread_mutex_unlock(&mutex);``

共有変数 a の操作が終わった直後に呼び出します。

これによりミューテックスが解放され、待機していた他のスレッドがロックを獲得できるようになります。

## なぜ正しく動作するのか
ミューテックスで保護されたことで、変数 a をインクリメントする処理（nextの計算からaへの代入まで）は
**アトミック（不可分）**
な操作として扱われます。

スレッドAが ``pthread_mutex_lock`` を呼び出してロックを獲得します。

スレッドAが a を読み込み、計算し、新しい値を a に書き込みます。

この間、もしスレッドBが ``pthread_mutex_lock`` を呼び出しても、スレッドAがロックを解放していないため、スレッドBはそこで待機させられます。

スレッドAが ``pthread_mutex_unlock`` を呼び出してロックを解放します。

ここで初めて、待機していたスレッドBがロックを獲得し、a への操作を開始できます。

この仕組みにより、2つのスレッドが中途半端に混ざり合って処理を行うことがなくなり、計算の欠落が発生しなくなります。

``if (now+1 != next)`` のチェックについて
このコードでは、ミューテックスによる保護が完璧なため、``int next = a + 1;`` と ``int now = a;`` の間に他のスレッドが割り込むことは絶対にありません。したがって、now と a の値は常に同じになり、now + 1 と next の値も常に等しくなります。

結果として、if文の条件は常に偽となり、"other theard change" というメッセージが表示されることはありません。

## まとめ
このコードは、pthread_mutex を使ってマルチスレッドプログラムにおける競合状態を正しく解決する方法を示しています。

共有リソースを特定する（int a）。

共有リソースを操作する範囲（クリティカルセクション）を決める。

その範囲の前後を ``pthread_mutex_lock`` と ``pthread_mutex_unlock`` で囲む。

