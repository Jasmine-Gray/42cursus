## minitalk

### server
- pid_t getpid()
    ```c
    <unistd.h>
    pid_t = プロセスIDのタイプ,符号なし整数データ型。
    自分のプロセスID を戻り値として返す。
    ```

- int pause(void)
    ```c
    <unistd.h>

    呼び出したプロセス（またはスレッド）を、シグナルを受取り終了させられるか、シグナル捕獲関数が呼び出されるまでスリープさせる。
    ```
- g_rxbuffer = (g_rxbuffer << 1) | (signum == SIGUSR1);
    ```c
    g_rxbuffer << 1:
    g_rxbuffer の値を左に1ビットシフト。
    現在のバッファの内容を1ビット左にずらす操作。
    
    signum == SIGUSR1:
    受信したシグナル signum が SIGUSR1 であるかどうかをチェック。
    signum が SIGUSR1 であれば、この式は 1。
    signum が SIGUSR1 でなければ、この式は 0。

    ビットの OR 演算 |:
    左にシフトされた g_rxbuffer の末尾に、signum == SIGUSR1 の結果をビット単位で OR 演算する。
    これにより、新しいビットが g_rxbuffer の最下位ビットに追加される。
    ビットの OR 演算は、2つのビット列を比較し、それぞれのビット位置で少なくとも1つのビットが1であれば、そのビット位置の結果を1にする演算。どちらのビットも0の場合、そのビット位置の結果は0になる。

    ```

### client
- int kill(pid_t pid, int sig)
    ```c
    <signal.h>
    プロセスにシグナルを送る。
    
    - 返り値 
    正の値 シグナル sig が pid で指定された ID を持つプロセスに送られる。
    0 呼び出し元のプロセスのプロセスグループに属するすべてのプロセスに sig で指定したシグナルが送られる。
    -1 | sig で指定したシグナルが、呼び出し元のプロセスがシグナルを送る許可を持つ全てのプロセスに 送られる。 但し、プロセス番号 1 (init) へはシグナルは送られない。
    -1より小さい値 | ID が -pid のプロセスグループに属するすべてのプロセスに sig で指定したシグナルが送られる。


    if (kill(pid, 0) == -1)
    kill 関数は指定されたプロセスにシグナルを送信するために使われる。
    しかし、シグナル番号として 0 を指定した場合、実際にはシグナルは送信されない。
    代わりに、プロセスが存在するか、現在のプロセスがそのプロセスにシグナルを送信する権限があるかをチェックする。
    pid が存在しない場合や、シグナルを送信する権限がない場合、この関数は -1 を返す。
    ```
- int sigemptyset(sigset_t *set)
    ```c
    <signal.h>
    シグナル・セットsetを、から集合に初期設定する。
    認識されたシグナルはすべて除外される。

    シグナル・セット->
        シグナル・グループを一つのプロセスにより、経過の記録を取るためのデータ・オブジェクト

    sigemptyset(&sa.sa_mask)  でsaのシグナルマスクをクリアする。
    
    シグナルマスク->
    「○○のシグナルハンドラの実行中は、××のシグナルは無視する」というときに便利
    シグナルは、イベントが起こるとプログラムの実行部分に関係なく割り込んでくるため、それを防ぐことができる。
    sigemptyset()でシグナルマスクをゼロクリアできる。

    sigemptyset(&sa.sa_mask);
    ```
- unsigned int sleep(unsigned int seconds)
    ```c
    指定の秒数の間だけ休止する。
    ```

- sigaction 
    ```c
    sigactionを使うときは構造体が必要。

    struct sigaction {
    void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);
    };

    struct sigaction sa;
    ```
    ```c
    sigactionを使用すれば、シグナルをトリガーにして、関数を起動できる。
    sigactionは一度動かすとプロセス終了までずっと設定したシグナルをキャッチしてくれる。

    void	receiver(void handler(int, siginfo_t *, void *))
    {
    	struct sigaction	act;
    
    	bzero(&act, sizeof(struct sigaction));
    	act.sa_sigaction = handler;
    	sigemptyset(&act.sa_mask);
    	act.sa_flags = SA_SIGINFO;
    	sigaction(SIGUSR1, &act, NULL);
    	sigaction(SIGUSR2, &act, NULL);
    }
    
    bzeroで構造体の初期化
    sigemptysetでシグナルの初期化
    act.sa_flags = SA_SIGINFO;でhandler関数を使用する設定にする。
    sigactionは第一引数にどのシグナルをトリガーにするか設定。
    複数のシグナルで同じ関数を動かすときには、上記のように複数回呼び出す。
    ```
    ```c
    連続してシグナルを送る場合のインターバルの設定
    文字列をbitに変換し、プロセスに送り、連続して何度もシグナルを送る。

    void	send_char(pid_t pid, char c)
    {
    	int				bit;
    	int				i;
    	unsigned char	uc;

    	uc = (unsigned char)c;
    	i = 0;
    	while (i < 8)
    	{
    		usleep(50);
    		bit = (uc >> i) & 0x01;
    		if (kill(pid, SIGUSR1 + bit) == -1)
    			fatal("kill error");
    		i++;
    	}
    }
    ```
- SIGUSR1 SIGUSR2
    ```c    
    アプリケーションが独自の目的で自由に利用できるシグナル。デフォルトでは特別な動作が割り当てられていない。プログラムの設計者が任意の動作を設定できる。
    ```

## bonus
argv[][]分送り終わったら、NULL文字を最後に送る。
```c
 server側がNULL文字をキャッチしたら、
 client側にシグナルを送り返す。
 ボーナスをするには sigaction() を使用して構造体で記憶しておく必要がある。
 clientに送り返すときは、signal()や kill()を使用する。
```

1. SA_SIGINFO フラグを設定する理由
```c
SA_SIGINFO フラグを設定することで、シグナルハンドラは sa_handler の代わりに sa_sigaction を使用。これにより、シグナルハンドラは追加の情報を受け取ることができる。このフラグを設定すると、シグナルハンドラ関数は以下の3つの引数を受け取ることができる。

- int signum：受信したシグナルの番号。
- siginfo_t *info：シグナルに関する追加情報（シグナルを送信したプロセスの PID など）。
- void *context：シグナルが発生したときのプロセスのコンテキスト情報
```
2. sa_handler の代わりに sa_sigaction を使用する理由
```c
sa_handler を使用すると、シグナルハンドラ関数はシグナル番号（int signum）のみを引数として受け取る。
しかし、sa_sigaction を使用すると、追加の情報（siginfo_t *info と void *context）も受け取ることができる。
具体的には、siginfo_t 構造体を通じてシグナルの発信元（シグナルを送信したプロセスの PID）などの詳細な情報を取得できる。
これにより、シグナルの処理をより柔軟かつ詳細に行うことが可能。
```

3. void *context 引数を追加する理由
```c
void *context 引数は、シグナルが発生したときのプロセスの状態（コンテキスト）を示している。
この引数は ucontext_t 構造体へのポインタであり、シグナル発生時のプロセスのレジスタやスタック情報を含んでいる。
多くの場合、この情報は必要ないが、デバッグや特定の詳細なシグナル処理を行う際には役立つことがある。
コード内では (void)context; として未使用の引数を無視している。
```

- kill(info->si_pid, SIGUSR1);
```c
if (c == 0):
    受信した文字 (c) がヌル文字 (\0) であるかどうかをチェック。

kill(info->si_pid, SIGUSR1):
    kill 関数を使用して、指定されたプロセスにシグナルを送信。
    info->si_pid は、シグナルを送信したプロセス（クライアント）のプロセスID。
    これは、siginfo_t 構造体を通じて提供される。
    SIGUSR1 は、ユーザー定義のシグナルで、ここではサーバーがクライアントにメッセージの終わりを確認するために使用される。

具体的な動作
    クライアントがサーバーにメッセージを送信し、サーバーがそのメッセージをビット単位で受信。
    サーバーが8ビット（1バイト）を受信すると、そのバイトがヌル文字 (\0) かどうかを確認。
    ヌル文字であれば、メッセージの終わりを示すため、サーバーはクライアントに SIGUSR1 シグナルを送信。
    このシグナルは、クライアントにメッセージが正常に受信されたことを通知するための確認シグナルとして機能する。
```

### Global variable
```c
グローバル変数は、異なる関数やコードのセクション間でデータや状態を共有するために使われる。例えば、シグナルハンドラやコールバック関数のように、特定のイベントが発生したときに実行される関数でデータを保持する必要がある場合に便利。

プログラムの実行中ずっと存在し続けるため、一度設定した値が失われることなく保持される。これにより、複数の関数が同じ変数にアクセスして値を読み書きすることができる。

サーバー側コード
    static int g_rxbuffer;
g_char_bufは、受信したビットを一時的に保持するためのバッファであり、シグナルハンドラ内で使用される。シグナルハンドラは通常、標準の関数呼び出しとは異なり、特定のイベント（シグナルの受信）によって呼び出されるため、関数の引数としてデータを渡すことができない。このため、グローバル変数を使用してデータを保持している。

クライアント側コード
    volatile sig_atomic_t g_ack_received
サーバーからのシグナルを一時的に保持するための変数。シグナルハンドラ内で受信したシグナルを保存し、メインの送信ループでその状態をチェックするために使用される。これにより、シグナルハンドラと送信ループ間でデータを共有することができる。
1. sig_atomic_tとは
　sig_atomic_tは、C言語で使用される特別なデータ型で、シグナル処理の文脈でのアトミック（不可分）操作を保証するために設計されている。
シグナルハンドラとプログラムの他の部分との間で、割り込みが入らずに一つの操作で完了することを保証する。
シグナルを受け取った時に、安全に読み書きができる特別な種類の変数。
sig_atomic_tの単語の意味 
「Signal Atomic Type」の略。 
「Signal」は、この型がシグナル処理の文脈で使用されることを指す。 
「Atomic」は、「分割不可能な」や「一つの単位として扱われる」という意味で、sig_atomic_t型の変数への読み書きが途中で割り込まれることなく、一連の操作として完結することを意味している。 
sig_atomic_t型の変数に対する操作は、中断されることなく始めから終わりまで安全に行われることが保証されている。 

2. volatileとの関係 volatile型修飾子は、変数が予期せずに変更される可能性があることをコンパイラに伝えるために使用される。 この型修飾子が変数に適用されると、コンパイラはその変数の値がいつでも変更され得ると仮定し、その変数に対する読み込みや書き込み操作を最適化しないようにする。 プログラムがその変数を使用するたびに、コンパイラは直接メモリからその値を読み取るか、または直接メモリに値を書き込む。

volatileとsig_atomic_tの関係
　sig_atomic_t型の変数は、シグナルハンドラとプログラムの他の部分との間で安全にデータをやり取りするために設計されている。
　一方で、volatile型修飾子は、その変数が予期しない方法で変更されうることを示すために使用される。
シグナルハンドラ内でsig_atomic_t型の変数を使用する際にvolatile型修飾子を併用することは、その変数がシグナル処理によって予期せず変更され得るという事実をコンパイラに伝え、適切な読み書き操作が行われるようにするために有効。

特性/役割	volatile	sig_atomic_t
目的	コンパイラに変数が予期せずに変更され得ることを通知。	
    シグナル処理中の変数への読み書きが一回の操作で完了することを保証する。
役割	最適化による読み書きの省略を防ぎ、毎回直接メモリから値を読み書きするようにする。	      
    シグナル処理と通常のプログラム実行の間でのデータの安全なやり取りを確実にする。
使用シーン	 
- 外部イベントや割り込みによる更新
- マルチスレッド環境での変数共有
- ハードウェアからのデータ読み取り	
- シグナルハンドラ内で使用する変数
- シグナル処理と通常のプログラム実行間のデータ共有

volatile ＋ sig_atomic_t ＝ 安全かつ予期せず変更され得る変数の、安定した扱いをする型。
```

### signal safety
```c
シグナルセーフティ（Signal Safety）とは、プログラムがシグナルハンドラ内で特定の操作を安全に実行できることを指す。シグナルは、UNIX系オペレーティングシステムにおいて、プロセス間で非同期的に通知を送るためのメカニズム。

シグナルハンドラ内で安全に呼び出せる関数は制限されている。これは、シグナルハンドラが非同期に実行されるため、通常の関数呼び出しによる競合やデッドロックを避けるため。シグナルセーフ関数として知られている関数は、POSIX標準で定義されている。

    シグナルセーフ関数の例

    _exit
    signal
    sigaction
    sigprocmask
    write
    read
    waitpid

    シグナルセーフでない操作の例

    動的メモリの割り当てや解放（malloc、free）
    標準入出力操作（printf、scanf）
    非シグナルセーフな関数の呼び出し

グローバル変数を使用して状態を記録し、メインループでその状態を処理する。
[signal safety](https://man7.org/linux/man-pages/man7/signal-safety.7.html)
```