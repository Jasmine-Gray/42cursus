## 1. 全体のアーキテクチャ：データの橋渡し

役割を明確に分けるために2つの主要な構造体を使用。

* **`t_game` (パーサー用)**: ファイルから読み取った「生のデータ」を一時的に保管する箱。
* **`t_data` (レンダリング用)**: 実際に画面を描画するために必要な「計算用データ」を保持する箱。

`main.c` で `setup_data` を実装したことで、パーサーが苦労して集めたマップや色情報が、描画エンジンに正しく引き継がれるように。これができていないと、計算機（レンダリング）に数字が入っていない状態になり、クラッシュが起こりうる。

---

## 2. 空間の解釈：グリッドと座標系

コンピュータにとって、マップはただの「文字の羅列」。それを `parse_map` で **2次元配列 (`char **grid`)** に変換。

* **世界座標**: マップの `(x, y)` は、数学的な座標平面として扱われる。
* **中心への配置 (`+ 0.5`)**: プレイヤーの座標を `(5.5, 10.5)` のように設定することで、1x1マスの正方形のちょうど真ん中に立たせる。これにより、壁に埋まるリスクを減らし、計算を安定させる。

---

## 3. 描画の核心：レイキャスティング・アルゴリズム

`raycast.c` で行っているのは、**「光線投射（Raycasting）」** という手法。

### DDA (Digital Differential Analyzer)

これが今回最も重要なアルゴリズム。
3Dゲームにおいて「壁に当たったか」を判定するために、光線を 0.001 ずつ進めてチェックするのは非常に非効率。そこで **DDA** を使う。

* **仕組み**: 光線が次に「マスの境界線（縦線または横線）」をまたぐ瞬間だけを計算して、ワープするように進む。
* **メリット**: 計算回数が劇的に減り、1990年代の非力なコンピュータでもリアルタイムで3Dを表示できた。

---

## 4. 投影の数学：魚眼レンズの補正

光線が壁に当たったら、その距離を測定。しかし、単にプレイヤーからの直線距離を使うと、画面の両端が歪む **「魚眼レンズ効果」** が発生してしまう。

* **解決策**: プレイヤーの向きに対して **垂直な距離（Perpendicular distance）** を計算。これが `get_perp_dist` の役割。
* **3D化の魔法**: 壁の高さ  は、距離  に反比例。このシンプルな計算だけで、遠くの壁は小さく、近くの壁は大きく描画され、奥行きが生まれる。

---

## 5. グラフィックの実装：MiniLibX

描画には MiniLibX を使用していますが、標準の `mlx_pixel_put` ではなく、**イメージバッファへの直接書き込み**（`my_pixel_put`）を実装。

* **なぜ？**: `mlx_pixel_put` は1ピクセルごとにOSに描画を依頼するため非常に遅い。
* **高速化**: メモリ上に「1フレーム分の画像の設計図」を一気に作り、最後にドカンと1回だけ画面に転送することで、滑らかな描写（60FPS以上）を可能に。

---